#!/usr/bin/env bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null
trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd)."' ERR

#set -x

sourceDir="$(readlink -f "$1")"

destDir="$(readlink -f "$2")"

[[ -e "$destDir" ]] && rm -r "$destDir"

rsync -a --checksum "$sourceDir/" "$destDir"

cd "$destDir" || die

if [[ ! -f "futuramerlin-web-toolkit-discography.conf" ]]; then
    die "Couldn't find discography configuration file!"
fi

# Where the discography assets are located
assets="/usr/local/share/futuramerlin-web-toolkit/assets/discography.assets"

# Variables
indexBreadcrumbs="$(<futuramerlin-web-toolkit-discography.breadcrumbs)"
indexBreadcrumbs="    ${indexBreadcrumbs//$'\n'/$'\n'    }"
indexBreadcrumbs="${indexBreadcrumbs%    }"
discographyPageName="$(preadconf filename futuramerlin-web-toolkit-discography.conf)"
trackCounter=0

getRelativeDiscographyDir() {
    # pwd 1>&2
    if [[ -f "futuramerlin-web-toolkit-discography.conf" ]]; then
        print "./"
    elif [[ -f "../futuramerlin-web-toolkit-discography.conf" ]]; then
        print "../"
    elif [[ -f "../../futuramerlin-web-toolkit-discography.conf" ]]; then
        print "../../"
    elif [[ -f "../../../futuramerlin-web-toolkit-discography.conf" ]]; then
        print "../../../"
    fi
}

mergeConfFile() {
    local dir
    dir="$(getRelativeDiscographyDir)"
    inheritFrom="$dir"/works/"$(basename "$(pwd)")".conf
    while IFS= read -r line; do
        if ! [[ "$line" =~ ^# ]]; then
            key="$(cut -f1 -d, <<< "$line")"
            if ! grep -P "^$key," "$dir/$1" > /dev/null; then
                printf "%s\\n" "$line" >> "$dir/$1"
            fi
        fi
    done < "$inheritFrom"
}

for file in works/*/*.conf; do
    (
        cd "$(dirname "$file")" || die
        mergeConfFile "$file"
    )
done

getKindFolderName() {
    kind="$1"
    if [[ "$kind" == "press" ]]; then
        print "press"
    else
        print "${kind}s"
    fi
}

getKindLabel() {
    local kind="$1"
    local res
    res="$(getKindFolderName "$kind")"
    print "${res^}"
}

getItemPath() {
    # Returns the prefix pathname (e.g. releases/sylfan) of the referenced item, relative to the current directory.
    local kind="$1"
    local identifier="$2"
    # TODO: Make this able to handle more cases (it won't work for e.g. kind=work/sylfan)
    case "$kind" in
    kind)
        print "$(getRelativeDiscographyDir)$(getKindFolderName "$identifier")"
        ;;
    *)
        print "$(getRelativeDiscographyDir)$(getKindFolderName "$kind")/$identifier"
        ;;
    esac
}

discReadConf() {
    local key="$1"
    local kind="$2"
    local identifier="$3"
    echo "Reading configuration value $key from the $kind $identifier" 1>&2
    preadconf "$key" "$(getItemPath "$kind" "$identifier").conf"
}

getItemName() {
    local kind="$1"
    local identifier="$2"
    if [[ "$kind" == "kind" ]]; then
        getKindLabel "$identifier"
    elif [[ "$kind" == "session" ]]; then
        print "$identifier: $(discReadConf location "$kind" "$identifier")"
    else
        discReadConf name "$kind" "$identifier"
    fi
}

linkToItem() {
    local kind="$1"
    local identifier="$2"
    local usePicture="$3"
    local extraInfo="$4" # a formatting string like (@shortDate@)
    local picture=""
    local name
    local extension
    name="$(getItemName "$kind" "$identifier")"
    if [[ "$kind" == "kind" ]]; then
        extension=""
    else
        extension=".htm"
    fi
    if [[ "$usePicture" != "false" ]]; then
        local pictureType
        if [[ "$kind" == "release" ]]; then
            pictureType="album artwork"
        fi
        local picturePathName
        # .m.png = 50px; .t.png = 150px
        picturePathName="$(getItemPath "$kind" "$identifier").m.png"
        if [[ -e "$picturePathName" ]]; then
            picture="<img src=\"$picturePathName\" alt=\"$name: $pictureType thumbnail image\" /> "
        fi
    fi
    # TODO: Implement extraInfo
    print "<a href=\"$(getItemPath "$kind" "$identifier")$extension\">$picture$name</a>"
}

simpleMetadata() {
    print "<dt>$1</dt><dd>$2</dd>"
}

simpleReference() {
    local key="$1"
    local kind="$2"
    local identifier="$3"
    simpleMetadata "$(keyToLabel "$key")" "$(linkToItem "$kind" "$identifier")"
}

getEntryPoint() {
    local entryPointFile
    entryPointFile="futuramerlin-web-toolkit-discography.entry-point"
    if [[ -e "$entryPointFile" ]]; then
        print "$(<"$entryPointFile")"
    fi
}

listItem() {
    local filtered=""
    local filterKey
    local filterValue
    if [[ "$1" == "--filter" ]]; then
        filtered="true"
        shift
        filterKey="$1"
        shift
        filterValue="$1"
        shift
    fi
    local recursive="false"
    if [[ "$1" == "--recursive" ]]; then
        # It's recursive, so the outermost call to listItem will actually return the results for *all* items in the chain.
        recursive="true"
        shift
    fi
    # Remaining arguments are the same as for linkToItem
    local kind="$1"
    local identifier="$2"
    echo "Building list entry for an item: $kind $identifier. Recursive: $recursive" 1>&2
    local usePicture="$3"
    local extraInfo="$4" # a formatting string like (@shortDate@)
    local matchedFilter=""
    if [[ "$filtered" == "true" ]]; then
        if [[ "$(discReadConf "$filterKey" "$kind" "$identifier")" == "$filterValue" ]]; then
            matchedFilter="true"
        fi
    fi
    if [[ "$filtered" != "true" ]] || [[ "$matchedFilter" == "true" ]]; then
        print $'\n'"    <li>$(linkToItem "$@")</li>"
    fi
    if [[ "$recursive" == "true" ]]; then
        if [[ "$filtered" != "true" ]]; then
            # We need to call buildPage in here, because unlike with alphabetical lists, it won't be called by listRecursive
            buildPage "$identifier" "$(getItemName "$kind" "$identifier")" "$indexBreadcrumbs <span><a href=\"../$discographyPageName.htm\">Discography</a></span>" "Boo"
        fi
        # This is where we make the recursive call to listItem, if needed.
        local nextIdentifier
        nextIdentifier="$(discReadConf nextId "$kind" "$identifier")"
        [[ -n "$nextIdentifier" ]] && listItem --recursive "$kind" "$nextIdentifier" "$usePicture" "$extraInfo"
        true # needed because the if statement executes with the exit status of the last command executed
    fi
}

simpleIaLink() {
    local filename="$1"
    local localident="$2"
    local label="$3"
    local iaident
    iaident="$(preadconf ia "$localident")"
    print "<a href=\"https://archive.org/download/$iaident/$filename\">$label</a>"
}

simpleIaUrl() {
    local filename="$1"
    local localident="$2"
    local iaident
    iaident="$(preadconf ia "$localident")"
    print "https://archive.org/download/$iaident/$filename"
}

simpleIaImage() {
    local filename="$1"
    local localident="$2"
    local iaident
    iaident="$(preadconf ia "$localident")"
    local relname
    relname="$(preadconf name "$localident")"
    print "<a href=\"https://archive.org/download/$iaident/$filename.png\"><img src=\"https://archive.org/download/$iaident/t$filename.png\" alt=\"$relname: album artwork\" /></a>"
}

keyToLabel() {
    case $1 in
    dateBegun)
        print "Date begun"
        ;;
    mbid)
        print "MusicBrainz"
        ;;
    alac)
        print "M4A: Apple Lossless Audio Codec"
        ;;
    cdRip)
        print "CD Rip"
        ;;
    zipRelease)
        print "ZIP release <small>(historic packing)</small>"
        ;;
    artSource)
        print "Artwork production files"
        ;;
    soundSource)
        print "Music production files"
        ;;
    releaseTracks)
        print "Original release tracks <small>(packing not original)</small>"
        ;;
    nonPngArtwork)
        print "Nonstandard artwork"
        ;;
    fileIsSemanticallySignificant)
        print "File is semantically significant"
        ;;
    fmCatNum)
        print "Catalog number"
        ;;
    oldFmCatNum)
        print "Original catalog number"
        ;;
    hypFmCatNum)
        print "Two-part old catalog number"
        ;;
    isAliasOf)
        print "Is alias of"
        ;;
    hasAlias)
        print "Has alias"
        ;;
    legalName)
        print "Legal name"
        ;;
    ia)
        print "Internet Archive"
        ;;
    *)
        print "${1^}"
        ;;
    esac
}

buildTrackPlayer() {
    local kind="$1"
    local identifier="$2"
    local filename
    filename="$(discReadConf filename "$kind" "$identifier")"
    local extA
    extA="$(discReadConf origExt "$kind" "$identifier")"
    if [[ -n "$extA" ]]; then
        simpleIaLink "$filename.$extA" "$3" "Orig. ($extA)"
        print " "
    fi
    local extB
    extB="$(discReadConf origExtB "$kind" "$identifier")"
    if [[ -n "$extB" ]]; then
        simpleIaLink "$filename.$extB" "$3" "Orig. ($extB)"
        print " "
    fi
    local extC
    extC="$(discReadConf origExtC "$kind" "$identifier")"
    if [[ -n "$extC" ]]; then
        simpleIaLink "$filename.$extC" "$3" "Orig. ($extC)"
        print " "
    fi
    if [[ "$extA" == "flac" || "$extB" == "flac" || "$extC" == "flac" ]]; then
        local hasFlac="true"
    elif [[ "$extA" == "mp3" || "$extB" == "mp3" || "$extC" == "mp3" ]]; then
        local hasMp3="true"
    elif [[ "$extA" == "ogg" || "$extB" == "ogg" || "$extC" == "ogg" ]]; then
        local hasOgg="true"
    fi
    if ! [[ "$hasMp3" == "true" ]]; then
        simpleIaLink "$filename".mp3 "$3" "MP3"
        print " "
    fi
    if ! [[ "$hasFlac" == "true" ]]; then
        simpleIaLink "$filename".flac "$3" "FLAC"
        print " "
    fi
    if ! [[ "$hasOgg" == "true" ]]; then
        simpleIaLink "$filename".ogg "$3" "OGA"
    fi
    print "<br />"
    print "<audio controls preload=\"none\">"
    local formats=(flac ogg mp3)
    for format in "${formats[@]}"; do
        print "<source src=\""
        simpleIaLink "$filename.$format" "$3"
        print "\" type=\"audio/"
        if [[ "$format" == "mp3" ]]; then
            print "mpeg"
        else
            print "$format"
        fi
        print "\">"
    done
    print "Could not start audio player.</audio>"
}

traitToHtm() {
    local kind="$1"
    local identifier="$2"
    local key="$3"
    local value="$4"
    case "$key" in
    file)
        print "<li>$(simpleIaLink "$(cut -f2- -d, <<< "$value")" "$identifier" "$(keyToLabel "$(cut -f1 -d, <<< "$value")")")</li>"
        ;;
    nonPngArtwork)
        simpleMetadata "$(keyToLabel "$key")" "$(simpleIaLink "$value" "$identifier" "$value")"
        ;;
    fileIsSemanticallySignificant)
        if [[ "$value" == "yes" ]]; then
            simpleMetadata "$(keyToLabel "$key")" "yes"
        fi
        ;;
    artworkcount)
        local end="$value"
        for (( i=1; i<=end; i++ )); do
            simpleIaImage "$i" "$identifier"
            print ' '
        done
        ;;
    track)
        trackCounter=$(( trackCounter + 1 ))
        work="$(cut -f1 -d, <<< "$value")"
        subWork="$(cut -f2 -d, <<< "$value")"
        workPrefix="$(getRelativeDiscographyDir)/works/$work/$subWork"
        print "<tr><td>$trackCounter</td><td>$(buildTrackPlayer "$work" "$subWork" "$identifier")</td><td><a href=\"$workPrefix.htm\">$(preadconf name "$workPrefix.conf")</a></td><td>$(preadconf duration "$workPrefix.conf")</td><td>$(preadconf instrumentation "$workPrefix.conf")</td></tr>"
        ;;
    medium)
        simpleMetadata "$(keyToLabel "$key")" "$(keyToLabel "$value")"
        ;;
    label)
        simpleReference "$key" label "$value"
        ;;
    artist)
        simpleReference "$key" artist "$value"
        ;;
    shortDate)
        print ""
        ;;
    name)
        print ""
        ;;
    hasAlias)
        simpleReference "$key" artist "$value"
        ;;
    isAliasOf)
        simpleReference "$key" artist "$value"
        ;;
    "* Identifiers *")
        print "<h2>Identifiers</h2>"
        ;;
    "* Relationships *")
        print ""
        ;;
    "* Specs *")
        print ""
        ;;
    "* Files *")
        print "<h2>Files</h2><ul>"
        ;;
    "* Tracks *")
        print "</ul><h2>Track listing</h2><table><thead><tr><th>#</th><th>ðŸ”Š</th><th>Track name</th><th>Duration</th><th>Instrumentation</th></tr></thead><tbody>"
        ;;
    mbid)
        simpleMetadata "$(keyToLabel "$key")" "<a href=\"https://musicbrainz.org/${kind%s}/$value\">$value</a>"
        ;;
    ia)
        simpleMetadata "$(keyToLabel "$key")" "<a href=\"https://archive.org/details/$value\">$value</a>"
        ;;
    *)
        simpleMetadata "$(keyToLabel "$key")" "$value"
        ;;
    esac
}

buildLeafContents() {
    kind="$1"
    identifier="$2"
    if [[ "$kind" == "artist" ]] || [[ "$kind" == "label" ]]; then
        releasesList="$(listRecursive release --filter "$kind" "$identifier")"
        [[ -n "$releasesList" ]] && print '<h2>Releases</h2>'$'\n'"<ul>$releasesList"$'\n'"</ul>"
        true # needed because the if statement executes with the exit status of the last command executed
    fi
}

listRecursive() {
    kind="$1"
    local filtered=""
    local filterKey
    local filterValue
    if [[ "$2" == "--filter" ]]; then
        filtered="true"
        filterKey="$3"
        filterValue="$4"
    fi
    local entryPoint
    entryPoint="$(getEntryPoint)"
    if [[ -z "$entryPoint" ]]; then
        if [[ "$filtered" == "true" ]]; then
            listAlphabetical "$1" --filter "$filterKey" "$filterValue"
        else
            listAlphabetical "$1"
        fi
    else
        # We're making a chronological list, so start with the first item in the list (defined in the .entry-point file), and follow the chain along from there.
        if [[ "$filtered" == "true" ]]; then
            listItem --filter "$filterKey" "$filterValue" --recursive "$kind" "$entryPoint"
        else
            listItem --recursive "$kind" "$entryPoint"
        fi
    fi
}

listAlphabetical() {
    kind="$1"
    local filtered=""
    local filterKey
    local filterValue
    if [[ "$2" == "--filter" ]]; then
        filtered="true"
        filterKey="$3"
        filterValue="$4"
    fi
    itemList=""
    echo "Building alphabetical list of $kind (filtered: $filtered $filterKey $filterValue)" 1>&2
    for item in ../"$(getKindFolderName "$kind")"/*.conf; do
        itemName="$(basename "$item")"
        itemName="${itemName%\.conf}"
        # This causes the recursive page building, and doesn't have any effect on what this function returns.
        buildPage "$itemName" "$(getItemName "$kind" "$itemName")" "$indexBreadcrumbs <span><a href=\"../$discographyPageName.htm\">Discography</a></span>" "$(buildLeafContents "$kind" "$itemName")"
        # This appends the current item to the list that this function will return.
        if [[ "$filtered" == "true" ]]; then
            itemList="$itemList$(listItem --filter "$filterKey" "$filterValue" "$kind" "$itemName")"
        else
            itemList="$itemList$(listItem "$kind" "$itemName")"
        fi
    done
    print "$itemList"
}

buildList() {
    local kind="$1"
    echo "Building list for $kind" 1>&2
    print "<ul>"
    case "$kind" in
    kind)
        itemList=""
        indexItems=(artist label release work broadcast press session file)
        for item in "${indexItems[@]}"; do
            if [[ -e "$(getKindFolderName "$item")" ]]; then
                buildCategory "kind" "$item"
                itemList="$itemList$(listItem "kind" "$item")"
            fi
        done
        print "$itemList"
        ;;
    file)
        itemList="FIXME"
        ;;
    *)
        listRecursive "$kind"
        ;;
    esac
    print $'\n'"</ul>"
}

buildPage() {
    local destinationFile="$1"
    local pageTitle="$2"
    echo "Building page $pageTitle: $destinationFile.htm" 1>&2
    local pageBreadcrumbs="$3"
    local pageContent="$4"
    cp "$assets/template.htm" "$destinationFile.htm" || die
    ereplace "@TITLE@" "$pageTitle" "$destinationFile.htm"
    ereplace "@BREADCRUMBS@" "$pageBreadcrumbs" "$destinationFile.htm"
    ereplace "@BODY@" "$pageContent" "$destinationFile.htm"
}

buildCategory() {
    local kind="$1"
    local identifier="$2"
    echo "Building category for the $kind $identifier" 1>&2
    case "$kind" in
        index)
            buildPage "$discographyPageName" "Discography" "$indexBreadcrumbs" "$(buildList kind)"
            ;;
        kind)
            (
                cd "$(getKindFolderName "$identifier")" || die
                identifierCategoryName="$(getKindFolderName "$item")"
                buildPage "index" "${identifierCategoryName^}" "$indexBreadcrumbs"$'\n'"    <span><a href=\"../$discographyPageName.htm\">Discography</a></span>" "$(buildList "$identifier")"
            )
            ;;
        *)
            error-notify "buildCategory requested for unknown type $kind."
            ;;
    esac
}

buildCategory "index"
