#!/bin/bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null
trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO}."' ERR

set -x

if [[ ! -f "futuramerlin-web-toolkit-discography.conf" ]]; then
    die "Couldn't find discography configuration file!"
fi

# Where the discography assets are located
da="/usr/local/share/futuramerlin-web-toolkit/assets/discography.assets"

# Variables
indexBreadcrumbs="$(<futuramerlin-web-toolkit-discography.breadcrumbs)"
discographyPageName="$(preadconf filename futuramerlin-web-toolkit-discography.conf)"

function getRelativeDiscographyDir() {
    # pwd 1>&2
    if [[ -f "futuramerlin-web-toolkit-discography.conf" ]]; then
        print "./"
    elif [[ -f "../futuramerlin-web-toolkit-discography.conf" ]]; then
        print "../"
    elif [[ -f "../../futuramerlin-web-toolkit-discography.conf" ]]; then
        print "../../"
    elif [[ -f "../../../futuramerlin-web-toolkit-discography.conf" ]]; then
        print "../../../"
    fi
}

function mergeConfFile() {
    local dir
    dir="$(getRelativeDiscographyDir)"
    inheritFrom="$dir"/works/"$(basename "$(pwd)")".conf
    while IFS= read -r line; do
        if ! [[ "$line" =~ ^# ]]; then
            key="$(cut -f1 -d, <<< "$line")"
            if ! grep -P "^$key," "$dir/$1"; then
                printf "%s\n" "$line" >> "$dir/$1"
            fi
        fi
    done < "$inheritFrom"
}

for file in works/*/*.conf; do
    (
        cd "$(dirname "$file")" || die
        mergeConfFile "$file"
    )
done

function getKindFolderName() {
    kind="$1"
    if [[ "$kind" == "press" ]]; then
        print "press"
    else
        print "${kind}s"
    fi
}

function getItemPath() {
    # Returns the prefix pathname (e.g. releases/sylfan) of the referenced item, relative to the current directory.
    local kind="$1"
    local identifier="$2"
    # TODO: Make this able to handle more cases (it won't work for e.g. kind=work/sylfan)
    print "$(getRelativeDiscographyDir)${kind}s/$identifier"
}

function discReadConf() {
    local key="$1"
    local kind="$2"
    local identifier="$3"
    preadconf "$key" "$(getItemPath "$kind" "$identifier").conf"
}

function linkToItem() {
    local kind="$1"
    local identifier="$2"
    local usePicture="$3"
    local extraInfo="$4" # a formatting string like (@shortDate@)
    local picture=""
    if [[ "$usePicture" != "false" ]]; then
        local picturePathName="$(getItemPath "$kind" "$identifier").t.png"
        if [[ -e "$picturePathName" ]]; then
            picture="<img src=\"$picturePathName\" alt=\"$2: thumbnail image\" /> "
        fi
    fi
    local name
    name="$(discReadConf name "$kind" "$identifier")"
    # TODO: Implement extraInfo
    print "<a href=\"$(getItemPath "$kind" "$identifier").htm\">$picture$name</a>"
}

function simpleMetadata() {
    print "<dt>$1</dt><dd>$2</dd>"
}

function simpleReference() {
    local key="$1"
    local kind="$2"
    local identifier="$3"
    simpleMetadata "$(keyToLabel "$key")" "$(linkToItem "$kind" "$identifier")"
}

function listItem() {
    # Arguments are the same as for linkToItem
    print "<li>"$(linkToItem "$@")"</li>"
}

function simpleIaLink() {
    local filename="$1"
    local localident="$2"
    local label="$3"
    local iaident
    iaident="$(preadconf ia "$localident")"
    print "<a href=\"https://archive.org/download/$iaident/$filename\">$label</a>"
}

function simpleIaUrl() {
    local filename="$1"
    local localident="$2"
    local iaident
    iaident="$(preadconf ia "$localident")"
    print "https://archive.org/download/$iaident/$filename"
}

function simpleIaImage() {
    local filename="$1"
    local localident="$2"
    local iaident
    iaident="$(preadconf ia "$localident")"
    local relname
    relname="$(preadconf name "$localident")"
    print "<a href=\"https://archive.org/download/$iaident/$filename.png\"><img src=\"https://archive.org/download/$iaident/t$filename.png\" alt=\"$relname: album artwork\" /></a>"
}

function keyToLabel() {
    case $1 in
    dateBegun)
        print "Date begun"
        ;;
    mbid)
        print "MusicBrainz"
        ;;
    alac)
        print "M4A: Apple Lossless Audio Codec"
        ;;
    cdRip)
        print "CD Rip"
        ;;
    zipRelease)
        print "ZIP release <small>(historic packing)</small>"
        ;;
    artSource)
        print "Artwork production files"
        ;;
    soundSource)
        print "Music production files"
        ;;
    releaseTracks)
        print "Original release tracks <small>(packing not original)</small>"
        ;;
    nonPngArtwork)
        print "Nonstandard artwork"
        ;;
    fileIsSemanticallySignificant)
        print "File is semantically significant"
        ;;
    fmCatNum)
        print "Catalog number"
        ;;
    oldFmCatNum)
        print "Original catalog number"
        ;;
    hypFmCatNum)
        print "Two-part old catalog number"
        ;;
    isAliasOf)
        print "Is alias of"
        ;;
    hasAlias)
        print "Has alias"
        ;;
    legalName)
        print "Legal name"
        ;;
    ia)
        print "Internet Archive"
        ;;
    *)
        print "${1^}"
        ;;
    esac
}

function buildTrackPlayer() {
    local kind="$1"
    local identifier="$2"
    local filename
    filename="$(discReadConf filename "$kind" "$identifier")"
    local extA
    extA="$(discReadConf origExt "$kind" "$identifier")"
    if [[ -n "$extA" ]]; then
        simpleIaLink "$filename.$extA" "$3" "Orig. ($extA)"
        print " "
    fi
    local extB
    extB="$(discReadConf origExtB "$kind" "$identifier")"
    if [[ -n "$extB" ]]; then
        simpleIaLink "$filename.$extB" "$3" "Orig. ($extB)"
        print " "
    fi
    local extC
    extC="$(discReadConf origExtC "$kind" "$identifier")"
    if [[ -n "$extC" ]]; then
        simpleIaLink "$filename.$extC" "$3" "Orig. ($extC)"
        print " "
    fi
    if [[ "$extA" == "flac" || "$extB" == "flac" || "$extC" == "flac" ]]; then
        local hasFlac="true"
    elif [[ "$extA" == "mp3" || "$extB" == "mp3" || "$extC" == "mp3" ]]; then
        local hasMp3="true"
    elif [[ "$extA" == "ogg" || "$extB" == "ogg" || "$extC" == "ogg" ]]; then
        local hasOgg="true"
    fi
    if ! [[ "$hasMp3" == "true" ]]; then
        simpleIaLink "$filename".mp3 "$3" "MP3"
        print " "
    fi
    if ! [[ "$hasFlac" == "true" ]]; then
        simpleIaLink "$filename".flac "$3" "FLAC"
        print " "
    fi
    if ! [[ "$hasOgg" == "true" ]]; then
        simpleIaLink "$filename".ogg "$3" "OGA"
    fi
    print "<br />"
    print "<audio controls preload=\"none\">"
    local formats=(flac ogg mp3)
    for format in "${formats[@]}"; do
        print "<source src=\""
        simpleIaLink "$filename.$format" "$3"
        print "\" type=\"audio/"
        if [[ "$format" == "mp3" ]]; then
            print "mpeg"
        else
            print "$format"
        fi
        print "\">"
    done
    print "Could not start audio player.</audio>"
}

trackCounter=0
function traitToHtm() {
    local kind="$1"
    local identifier="$2"
    local key="$3"
    local value="$4"
    case "$key" in
    file)
        print "<li>$(simpleIaLink "$(cut -f2- -d, <<< "$value")" "$identifier" "$(keyToLabel "$(cut -f1 -d, <<< "$value")")")</li>"
        ;;
    nonPngArtwork)
        simpleMetadata "$(keyToLabel "$key")" "$(simpleIaLink "$value" "$identifier" "$value")"
        ;;
    fileIsSemanticallySignificant)
        if [[ "$value" == "yes" ]]; then
            simpleMetadata "$(keyToLabel "$key")" "yes"
        fi
        ;;
    artworkcount)
        local end="$value"
        for (( i=1; i<=end; i++ )); do
            simpleIaImage "$i" "$identifier"
            print ' '
        done
        ;;
    track)
        trackCounter=$(( trackCounter + 1 ))
        work="$(cut -f1 -d, <<< "$value")"
        subWork="$(cut -f2 -d, <<< "$value")"
        workPrefix="$(getRelativeDiscographyDir)/works/$work/$subWork"
        print "<tr><td>$trackCounter</td><td>$(buildTrackPlayer "$work" "$subWork" "$identifier")</td><td><a href=\"$workPrefix.htm\">$(preadconf name "$workPrefix.conf")</a></td><td>$(preadconf duration "$workPrefix.conf")</td><td>$(preadconf instrumentation "$workPrefix.conf")</td></tr>"
        ;;
    medium)
        simpleMetadata "$(keyToLabel "$key")" "$(keyToLabel "$value")"
        ;;
    label)
        simpleReference "$key" label "$value"
        ;;
    artist)
        simpleReference "$key" artist "$value"
        ;;
    shortDate)
        print ""
        ;;
    name)
        print ""
        ;;
    hasAlias)
        simpleReference "$key" artist "$value"
        ;;
    isAliasOf)
        simpleReference "$key" artist "$value"
        ;;
    "* Identifiers *")
        print "<h2>Identifiers</h2>"
        ;;
    "* Relationships *")
        print ""
        ;;
    "* Specs *")
        print ""
        ;;
    "* Files *")
        print "<h2>Files</h2><ul>"
        ;;
    "* Tracks *")
        print "</ul><h2>Track listing</h2><table><thead><tr><th>#</th><th>ðŸ”Š</th><th>Track name</th><th>Duration</th><th>Instrumentation</th></tr></thead><tbody>"
        ;;
    mbid)
        simpleMetadata "$(keyToLabel "$key")" "<a href=\"https://musicbrainz.org/${kind%s}/$value\">$value</a>"
        ;;
    ia)
        simpleMetadata "$(keyToLabel "$key")" "<a href=\"https://archive.org/details/$value\">$value</a>"
        ;;
    *)
        simpleMetadata "$(keyToLabel "$key")" "$value"
        ;;
    esac
}

function buildFilteredListEntry() {
    local haystackKind="$1"
    local haystackItem="$2"
    local needleKey="$3"
    local needleValue="$4"
    local destinationFile="$5"
    local recursive="$6"
    local workVersion="$7"
    local workReleases="$8"
    if [[ "$workReleases" == "true" ]]; then
        local relativePrefix
        relativePrefix="$(getRelativeDiscographyDir)/releases/$haystackItem"
        if grep -P "^track,$(basename "$needleKey")" "$relativePrefix".conf; then
            local releaseName
            releaseName="$(preadconf name "$haystackItem.conf")"
            local disambig
            disambig="$(preadconf disambig "$haystackItem.conf")"
            if [[ -n "$disambig" ]]; then
                disambig=" <small>$disambig</small>"
            fi
            listItem "$relativePrefix" "$releaseName$disambig" >> "$destinationFile"
        fi
    elif [[ "$workVersion" == "true" ]]; then
        local haystackPath
        haystackPath="$(getRelativeDiscographyDir)/works/${needleKey}/$haystackItem"
        haystackPath="${haystackPath%.conf}"
        local disambig
        disambig="$(preadconf disambig "$haystackPath".conf)"
        if [[ -n "$disambig" ]]; then
            disambig=" <small>$disambig</small>"
        fi
        listItem "$haystackPath" "$(preadconf name "$haystackPath".conf)$disambig" >> "$destinationFile"
    else
        haystackItem="${haystackItem#"$subst"}"
        haystackItem="${haystackItem%.conf}"
        local haystackConf
        haystackConf="$(getRelativeDiscographyDir)/${haystackKind}s/$haystackItem.conf"
        readconf "${needleKey}" "$haystackConf"
        foundMatch="false"
        if [[ "${#readconfValue[@]}" -gt 0 ]]; then
            for matchingCategory in "${readconfValue[@]:?}"; do
                if [[ "$matchingCategory" == "$needleValue" ]]; then
                    foundMatch="true"
                fi
            done
            if [[ "$foundMatch" == "true" ]]; then
                local name
                name="$(preadconf name "$haystackConf")"
                local disambig
                disambig="$(preadconf disambig "$haystackConf")"
                if [[ -n "$disambig" ]]; then
                    disambig=" <small>$disambig</small>"
                fi
                listItem "$(getRelativeDiscographyDir)/${haystackKind}s/$haystackItem" "$name$disambig" >> "$destinationFile"
            fi
        fi
    fi
    if [[ "$recursive" == "true" ]]; then
        local next
        if [[ "$workVersion" == "true" ]]; then
            next="$(preadconf nextEntry "$haystackPath".conf)"
        else
            next="$(preadconf nextEntry "$haystackItem".conf)"
        fi
        if [[ -n "$next" ]]; then
            buildFilteredListEntry "$haystackKind" "$next" "$needleKey" "$needleValue" "$destinationFile" "true" "$workVersion"
        fi
    fi
}

function buildFilteredList() {
    local destinationFile="$4"
    if [[ "$1" == "--workVersionReleases" ]]; then
        # List for the individual work version
        shift
        destinationFile="works/$(basename "$2")/$(basename "$5")"
        local workVersionReleases="true"
    elif [[ "$1" == "--workReleases" ]]; then
        # List of releases any version of the work appears on
        shift
        destinationFile="works/$(basename "$2")"
        local workReleases="true"
    elif [[ "$1" == "--workVersion" ]]; then
        # List of versions of the work
        shift
        local workVersion="true"
        destinationFile="$2"
    fi
    # Searches for items of type haystackKind with the given key-value pair. If recursive is specified, it will follow the nextEntry records, starting from the given haystackItem.
    if [[ "$workVersion" == "true" || "$workReleases" == "true" ]]; then
        needleKey="$1"
        subst="$(getRelativeDiscographyDir)/works/$needleKey/"
        if [[ "$workReleases" == "true" ]]; then
            subst="$(getRelativeDiscographyDir)/releases/"
        fi
    else
        local haystackKind="$1"
        local needleKey="$2"
        local needleValue="$3"
        local subst
        subst="$(getRelativeDiscographyDir)/${haystackKind}s/"
    fi
    (
        cd "$subst" || die
        if [[ -e futuramerlin-web-toolkit-discography.entry-point ]]; then
            buildFilteredListEntry "$haystackKind" "$(<futuramerlin-web-toolkit-discography.entry-point)" "$needleKey" "$needleValue" "$destinationFile" "true" "$workVersion" "$workReleases"
        else
            for haystackItem in *.conf; do
                buildFilteredListEntry "$haystackKind" "$haystackItem" "$needleKey" "$needleValue" "$destinationFile" "false" "$workVersion" "$workReleases"
            done
        fi
    )
}

function buildSinglePage() {
    local kind="$1"
    local identifier="$2"
    fn="$id.htm"
    declare -n ref=$category; ref+=( "$id" )
    # Build individual page
    cp "$da/item-template.htm" "$fn"
    name="$(preadconf name "$id.conf")"
    ereplace "@TITLE@" "$name" "$fn"
    ereplace "@BREADCRUMBS@" "$breadcrumbs <span><a href=\"../$discographyPageName.htm\">Discography</a></span> <span><a href=\"../$category\">${category^}</a></span>" "$fn"
    print "<dl>" >> "$fn"
    trackCounter=0
    while IFS= read -r line; do
        if ! [[ "$line" =~ ^# ]]; then
            key="$(cut -f1 -d, <<< "$line")"
            if ! [[ -z "$key" ]]; then
                traitToHtm "$category" "$id" "$key" "$(cut -f2- -d, <<< "$line")" >> "$fn"
            fi
        fi
    done < "$id.conf"
    print "</dl>" >> "$fn"
    if [[ "$category" == "labels" ]]; then
        # Generate index of artists on this label
        print "<h2>Artists</h2><ul>" >> "$fn"
        for artist in "$(getRelativeDiscographyDir)"/artists/*.conf; do
            buildFilteredListEntry "artist" "$artist" "label" "$id" "$fn"
        done
        print "</ul>" >> "$fn"
    fi
    if [[ "$category" == "artists" || "$category" == "labels" ]]; then
        # Generate list of releases
        print "<h2>Releases</h2><ul>" >> "$fn"
        local entryPoint
        entryPoint="$(getRelativeDiscographyDir)/releases/futuramerlin-web-toolkit-discography.entry-point"
        buildFilteredList "release" "$(<"$entryPoint")" "${category%s}" "$id" "$fn"
        print "</ul>" >> "$fn"
    fi
    if [[ "$category" == "works" ]]; then
        # Generate list of sub-works, and build a page for each
        print "<h2>Versions</h2><ul>" >> "$fn"
        buildFilteredList --workVersion "$id" "$fn"
        print "</ul><h2>Releases</h2><ul>" >> "$fn"
        buildFilteredList --workReleases "$id" "$fn"
        print "</ul>" >> "$fn"
        (
            cd "$id" || die
            local oCategory="$category"
            category="versions"
            for wversion in *.conf; do
                # true
                buildSinglePage "${wversion%.conf}"
            done
            category="$oCategory"
        )
    fi
    if [[ "$2" == "recursive" ]]; then
        local next
        next="$(preadconf nextEntry)"
        if [[ -n "$next" ]]; then
            buildSinglePage "$next" "recursive"
        fi
    fi
}

function buildList() {
    local kind="$1"
    print "<ul>"
    case "$kind" in
    kind)
        itemList=""
        indexItems=(artist label release work broadcast press session file)
        for item in "${indexItems[@]}"; do
            if [[ -e "$item" ]]; then
                buildPage "$kind" "$item"
                itemList="$itemList$(listItem "$kind" "$item")"
            fi
        done
        print itemList
        ;;
    *)
        die "Unknown type!"
        ;;
    esac
    print "</ul>"
}

function buildPage() {
    local destinationFile="$1"
    local pageTitle="$2"
    local pageBreadcrumbs="$3"
    local pageContent="$4"
    cp "$da/template.htm" "$destinationFile.htm" || die
    ereplace "@TITLE@" "$pageTitle" "$destinationFile.htm"
    ereplace "@BREADCRUMBS@" "$pageBreadcrumbs" "$destinationFile.htm"
    ereplace "@BODY@" "$pageContent" "$destinationFile.htm"
}

function buildCategory() {
    local kind="$1"
    local identifier="$2"
    case "$kind" in
    index)
        buildPage "$discographyPageName" "Discography" "$indexBreadcrumbs" "$(buildList kind)"
        ;;
    kind)
        (
            cd "$(getKindFolderName "$kind")" || die
            cp "$da/index-template.htm" index.htm
            ereplace "@TITLE@" "${kind^}" index.htm
            ereplace "@BREADCRUMBS@" "$breadcrumbs <span><a href=\"../$discographyPageName.htm\">Discography</a></span>" index.htm
            local itemList=""
            local categoryarray="${category}[@]"
            for item in "${!categoryarray}"; do
                local name
                name="$(preadconf name "$item.conf")"
                itemList="$itemList$(listItem "$item" "$name")"
            done
            ereplace "@LIST@" "$(buildList )" index.htm
        )
        ;;
    *)
        die "Unknown type!"
        ;;
    esac
}

buildCategory "index"
