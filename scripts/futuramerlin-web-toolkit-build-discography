#!/usr/bin/env bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null
#set -x

((EUID)) && exec sudo -- "$0" "$@"
trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd) at $(emdate)."' ERR

sourceDir="$(readlink -f "$1")"

destDir="$(readlink -f "$2")"

[[ -e "$destDir" ]] && rm -r "$destDir"

rsync -a --checksum "$sourceDir/" "$destDir"

cd "$destDir" || die

if [[ ! -f "futuramerlin-web-toolkit-discography.conf" ]]; then
    die "Couldn't find discography configuration file!"
fi

# Where the discography assets are located
assets="/usr/local/share/futuramerlin-web-toolkit/assets/discography.assets"

# Variables
indexBreadcrumbs="$(<futuramerlin-web-toolkit-discography.breadcrumbs)"
indexBreadcrumbs="    ${indexBreadcrumbs//$'\n'/$'\n'    }"
indexBreadcrumbs="${indexBreadcrumbs%    }"
discographyPageName="$(preadconf filename futuramerlin-web-toolkit-discography.conf)"
[[ -z "$discographyPageName" ]] && discographyPageName="discography"
trackCounterFile="$(readlink -f futuramerlin-web-toolkit-discography.conf).tc.temp"
echo "0" > "$trackCounterFile"
closingTagFile="$(readlink -f futuramerlin-web-toolkit-discography.conf).temp"
touch "$closingTagFile"

discogDebug() {
    #echo "$@" 1>&2
    true
}

getRelativeDiscographyDir() {
    # discogDebug "$(pwd)"
    if [[ -f "futuramerlin-web-toolkit-discography.conf" ]]; then
        print "./"
    elif [[ -f "../futuramerlin-web-toolkit-discography.conf" ]]; then
        print "../"
    elif [[ -f "../../futuramerlin-web-toolkit-discography.conf" ]]; then
        print "../../"
    elif [[ -f "../../../futuramerlin-web-toolkit-discography.conf" ]]; then
        print "../../../"
    fi
}

mergeConfFile() {
    local inheritInto="$1"
    local inheritFrom
    inheritFrom="works/$(basename "$(dirname "$inheritInto")").conf"
    discogDebug "Merging from $inheritFrom into $inheritInto"
    while IFS= read -r line; do
        local pattern='^#'
        if ! [[ "$line" =~ $pattern ]]; then
            local nextIdPattern='^nextId,'
            if ! [[ "$line" =~ $nextIdPattern ]]; then
                local key="${line%%,*}"
                if ! grep -P "^$key," "$inheritInto" > /dev/null; then
                    printf "%s\\n" "$line" >> "$inheritInto"
                fi
            fi
        fi
    done < "$inheritFrom"
}

for file in works/*/*.conf; do
    mergeConfFile "$file"
done

getKindFolderName() {
    local kind="$1"
    local pattern='.*\/.*'
    if [[ "$kind" =~ $pattern ]]; then
        # This kind is for a sub-item
        local key="${kind%%\/*}"
        local value="${kind#*\/}"
        print "$(getKindFolderName "$key")/$value"
    elif [[ "$kind" == "press" ]]; then
        print "press"
    else
        print "${kind}s"
    fi
}

getKindLabel() {
    local kind="$1"
    local kindFolderName
    kindFolderName="$(getKindFolderName "$kind")"
    print "${kindFolderName^}"
}

getItemPath() {
    # Returns the prefix pathname (e.g. releases/sylfan) of the referenced item, relative to the current directory.
    local kind="$1"
    local identifier="$2"
    case "$kind" in
        kind)
            print "$(getRelativeDiscographyDir)$(getKindFolderName "$identifier")"
            ;;
        *)
            print "$(getRelativeDiscographyDir)$(getKindFolderName "$kind")/$identifier"
            ;;
    esac
}

discReadConf() {
    local key="$1"
    local kind="$2"
    local identifier="$3"
    #discogDebug "Reading configuration value $key from the $kind $identifier"
    local result
    if [[ -e "$(getItemPath "$kind" "$identifier").conf" ]]; then
        result="$(preadconf "$key" "$(getItemPath "$kind" "$identifier").conf")"
    else
        result=""
    fi
    if [[ -z "$result" ]]; then
        if [[ "$key" == "name" ]]; then
            result="$identifier <small><!-- note: discReadConf for the $key of $kind $identifier is undefined or empty; using identifier instead. --><em>(No $key given: identifier used instead)</em></small>"
        elif [[ "$key" == "location" ]]; then
            result="<small><!-- note: discReadConf for the $key of $kind $identifier is undefined or empty. --><em>(No $key given)</em></small>"
        fi
    fi
    if [[ -z "$result" ]] && [[ ! -e "$(getItemPath "$kind" "$identifier").conf" ]] && [[ "$key" != "disambig" ]]; then
        result="<!-- placeholder: discReadConf for the $1 of $2 $3 is undefined. -->"
    fi
    print "$result"
}

getItemName() {
    local kind="$1"
    local identifier="$2"
    if [[ "$kind" == "kind" ]]; then
        getKindLabel "$identifier"
    elif [[ "$kind" == "session" ]]; then
        print "$identifier: $(discReadConf location "$kind" "$identifier")"
    else
        discReadConf name "$kind" "$identifier"
    fi
}

linkToItem() {
    local includeArtistName=""
    if [[ "$1" == "--with-artist-name" ]]; then
        includeArtistName="true"
        shift
    fi
    local includeDate=""
    if [[ "$1" == "--with-date" ]]; then
        includeDate="true"
        shift
    fi
    local releaseIndexPageFormat=""
    if [[ "$1" == "--release-index-page-format" ]]; then
        releaseIndexPageFormat="true"
        includeDate="true"
        shift
    fi
    local kind="$1"
    local identifier="$2"
    local usePicture="$3"
    local extraInfo="$4" # a formatting string like (@shortDate@)
    local picture=""
    local shortDate=""
    local disambig=""
    local extension
    local pattern='work\/.*'
    local name
    name="$(getItemName "$kind" "$identifier")"
    if [[ "$kind" == "kind" ]]; then
        extension=""
    else
        if [[ "$includeDate" == "true" ]]; then
            shortDate="$(discReadConf shortDate "$kind" "$identifier")"
            if [[ -z "$shortDate" ]]; then
                shortDate="$(discReadConf date "$kind" "$identifier")"
            fi
            if [[ -n "$shortDate" ]]; then
                shortDate=" ($shortDate)"
            else
                shortDate=""
            fi
        fi
        disambig="$(discReadConf disambig "$kind" "$identifier")"
        if [[ -n "$disambig" ]]; then
            disambig=" <small>($disambig)</small>"
        else
            disambig=""
        fi
        extension=".htm"
    fi
    if [[ "$kind" =~ $pattern ]]; then
        local contextValue
        contextValue="$(discReadConf context "$kind" "$identifier")"
        local contextKind="${contextValue%%,*}"
        print "${contextKind^} $(linkToItem --with-date "$contextKind" "${contextValue#*,}" false): "
    fi
    linkFirstPart="<a href=\"$(getItemPath "$kind" "$identifier")$extension\">"
    local artistNameInsert
    local releaseIndexPageFormatInsert=""
    if [[ "$includeArtistName" == "true" ]]; then
        local artistId
        artistId="$(discReadConf artist "$kind" "$identifier")"
        artistNameInsert="$(discReadConf fmCatNum "$kind" "$identifier") — $(discReadConf name artist "$artistId"): $linkFirstPart"
        if [[ "$usePicture" == "false" ]]; then
            linkFirstPart=""
        else
            artistNameInsert="</a> $artistNameInsert"
        fi
    elif [[ "$releaseIndexPageFormat" == "true" ]]; then
        local artistId
        artistId="$(discReadConf artist "$kind" "$identifier")"
        local labelId
        labelId="$(discReadConf label "$kind" "$identifier")"
        artistNameInsert="$(discReadConf name artist "$artistId") — $linkFirstPart"
        releaseIndexPageFormatInsert=" ($(discReadConf name label "$labelId") #$(discReadConf fmCatNum "$kind" "$identifier"))"
        if [[ "$usePicture" == "false" ]]; then
            linkFirstPart=""
        else
            artistNameInsert="</a> $artistNameInsert"
        fi
    else
        artistNameInsert=""
    fi
    if [[ "$usePicture" != "false" ]]; then
        local pictureType
        if [[ "$kind" == "release" ]]; then
            pictureType="album artwork"
        fi
        local picturePathName
        # m.png = 50px; t.png = 150px
        picturePathName="$(getItemPath "$kind" "$identifier")/m.png"
        if [[ -e "$picturePathName" ]]; then
            picture="<img src=\"$picturePathName\" alt=\"$(htmlToText.pl <<< "$name" | normalizeWhitespace): $pictureType thumbnail image\" width=\"50\" />"
            if [[ "$artistNameInsert" == "" ]]; then
                artistNameInsert=" "
            fi
        fi
    fi
    # TODO: Implement extraInfo
    print "$linkFirstPart$picture$artistNameInsert$name</a>$releaseIndexPageFormatInsert$disambig$shortDate"
}

simpleMetadata() {
    print "<dt>$1</dt><dd>$2</dd>"
}

simpleReference() {
    local key="$1"
    local kind="$2"
    local identifier="$3"
    simpleMetadata "$(keyToLabel "$key")" "$(linkToItem "$kind" "$identifier")"
}

getEntryPoint() {
    local kind="$1"
    kind="$(getKindFolderName "$kind")"
    local entryPointFile
    entryPointFile="$(getRelativeDiscographyDir)/$kind/futuramerlin-web-toolkit-discography.entry-point"
    if [[ -e "$entryPointFile" ]]; then
        print "$(<"$entryPointFile")"
    fi
}

getLeafBreadcrumbs() {
    local kind="$1"
    local superKind="$2"
    local pattern='.*\/.*'
    if [[ "$kind" != "kind" ]] && [[ "$kind" != "index" ]]; then
        if [[ "$kind" =~ $pattern ]]; then
            # This kind is for a sub-item
            local key="${kind%%\/*}"
            local value="${kind#*\/}"
            getLeafBreadcrumbs "$key"
            getLeafBreadcrumbs "$value" "$key"
        else
            print $'\n''    <span><a href="'
            getRelativeDiscographyDir
            if [[ -n "$superKind" ]]; then
                print "$(getKindFolderName "$superKind")/$kind.htm"
            else
                print "$(getKindFolderName "$kind")"
            fi
            print '">'
            if [[ -n "$superKind" ]]; then
                getItemName "$superKind" "$kind"
            else
                getKindLabel "$kind"
            fi
            print "</a></span>"
        fi
    fi
}

getBreadcrumbs() {
    local kind="$1"
    print "$indexBreadcrumbs"$'\n'"    <span><a href=\"$(getRelativeDiscographyDir)$discographyPageName.htm\">Discography</a></span>"
    getLeafBreadcrumbs "$kind"
}

getSubKind() {
    local kind="$1"
    local pattern='.*\/.*'
    if [[ "$kind" =~ $pattern ]]; then
        getRelativeDiscographyDir
        getKindFolderName "$kind"
        print "/"
    fi
}

getKindDisplayNameInsert() {
    local kindDisplayNameInsert
    kindDisplayNameInsert="$1"
    local pattern='.*\/.*'
    if [[ "$kindDisplayNameInsert" =~ $pattern ]]; then
        print " — Work Instance"
    else
        print " — ${kindDisplayNameInsert^}"
    fi
}

listItem() {
    local filtered=""
    local filterKey
    local filterValue
    if [[ "$1" == "--filter" ]]; then
        filtered="true"
        shift
        filterKey="$1"
        shift
        filterValue="$1"
        shift
    fi
    local recursive="false"
    if [[ "$1" == "--recursive" ]]; then
        # It's recursive, so the outermost call to listItem will actually return the results for *all* items in the chain.
        recursive="true"
        shift
    fi
    # Remaining arguments are the same as for linkToItem
    local kind="$1"
    local identifier="$2"
    discogDebug "Building list entry for an item: $kind $identifier. Recursive: $recursive. Filtered: $filtered $filterKey $filterValue"
    local usePicture="$3"
    local extraInfo="$4" # a formatting string like (@shortDate@)
    local matchedFilter=""
    if [[ "$filtered" == "true" ]]; then
        if [[ "$(discReadConf "$filterKey" "$kind" "$identifier")" == "$filterValue" ]]; then
            matchedFilter="true"
        fi
    fi
    if [[ "$filtered" != "true" ]] || [[ "$matchedFilter" == "true" ]]; then
        if [[ "$filtered" != "true" ]] && [[ "$kind" == "release" ]]; then
            print $'\n'"    <li>$(linkToItem --release-index-page-format "$@")</li>"
        else
            if [[ "$filterKey" == "label" ]]; then
                # Also print the artist name
                print $'\n'"    <li>$(linkToItem --with-artist-name --with-date "$@")</li>"
            else
                if [[ "$kind" == "broadcast" ]] || [[ "$kind" == "file" ]] || [[ "$kind" == "press" ]] || [[ "$kind" == "release" ]] || [[ "$kind" == "work" ]]; then
                    print $'\n'"    <li>$(linkToItem --with-date "$@")</li>"
                else
                    print $'\n'"    <li>$(linkToItem "$@")</li>"
                fi
            fi
        fi
    fi
    if [[ "$kind" == "kind" && "$identifier" == "release" ]]; then
        cp "$assets/featured-template-head.htm" "featured.htm" || die
        ereplace "@TITLE@" "Featured $(getItemName "$kind" "$identifier")" "featured.htm"
        ereplace "@BREADCRUMBS@" "$(getBreadcrumbs "$kind")" "featured.htm"
    fi
    if [[ "$recursive" == "true" ]]; then
        if [[ "$filtered" != "true" ]]; then
            if [[ "$kind" == "release" ]]; then
                buildLeafContents --featured-navigation-link "$kind" "$identifier" >> "../featured.htm.navigation"
                buildLeafContents --featured-content "$kind" "$identifier" > "../featured.htm.content.tmp"
                # FIXME: Workaround for a bug(?) in ereplace
                # ereplace '\' '\\' "../featured.htm.content.tmp"
                perl -0777 -p -i -e 's/\\/\\/g' "../featured.htm.content.tmp"
                ereplace $'\n' '\n' "../featured.htm.content.tmp"
                print $'\n' >> "../featured.htm.content.tmp"
                cat "../featured.htm.content.tmp" >> "../featured.htm.content"
                rm "../featured.htm.content.tmp"
            fi
            # We need to call buildPage in here, because unlike with alphabetical lists, it won't be called by listRecursive
            buildPage "$(getSubKind "$kind")$identifier" "$(getItemName "$kind" "$identifier")$(getKindDisplayNameInsert "$kind")" "$(getBreadcrumbs "$kind")" "$(buildLeafContents "$kind" "$identifier")"
        fi
        # This is where we make the recursive call to listItem, if needed.
        local nextIdentifier
        nextIdentifier="$(discReadConf nextId "$kind" "$identifier")"
        if [[ "$filtered" == "true" ]]; then
            [[ -n "$nextIdentifier" ]] && listItem --filter "$filterKey" "$filterValue" --recursive "$kind" "$nextIdentifier" "$usePicture" "$extraInfo"
        else
            [[ -n "$nextIdentifier" ]] && listItem --recursive "$kind" "$nextIdentifier" "$usePicture" "$extraInfo"
        fi
        true # needed because the if statement executes with the exit status of the last command executed
    fi
}

simpleIaLink() {
    local kind="$1"
    local identifier="$2"
    local iafilename="$3"
    local label="$4"
    local iaident
    iaident="$(discReadConf ia "$kind" "$identifier")"
    print "<a href=\"https://archive.org/download/$iaident/$iafilename\">$label</a>"
}

simpleIaUrl() {
    local kind="$1"
    local identifier="$2"
    local iafilename="$3"
    local iaident
    iaident="$(discReadConf ia "$kind" "$identifier")"
    print "https://archive.org/download/$iaident/$iafilename"
}

simpleIaImage() {
    local isFeaturedContentInsert=""
    if [[ "$1" == "--featured-content-page" ]]; then
        isFeaturedContentInsert="releases/"
        shift
    fi
    local kind="$1"
    local identifier="$2"
    local iafilename="$3"
    local reverseThumbnailPattern="$4"
    local iaident
    iaident="$(discReadConf ia "$kind" "$identifier")"
    local thumbnailName="$iafilename"t
    if [[ "$reverseThumbnailPattern" == "true" ]]; then
        thumbnailName="t$iafilename"
    fi
    local relname
    relname="$(discReadConf name "$kind" "$identifier")"
    print "<a href=\"https://archive.org/download/$iaident/$iafilename.png\"><img src=\"$isFeaturedContentInsert$identifier/$thumbnailName.png\" alt=\"$(htmlToText.pl <<< "$relname" | normalizeWhitespace): album artwork\" width=\"150\" /></a>"
}

keyToLabel() {
    case $1 in
        dateBegun)
            print "Date begun"
            ;;
        shortDate)
            print "Date"
            ;;
        artworkcount)
            print "Artwork"
            ;;
        mbid)
            print "MusicBrainz"
            ;;
        upc)
            print "UPC"
            ;;
        transcodedForSoundrop)
            print "Transcoded for Soundrop distribution"
            ;;
        ytdled)
            print "<code>youtube-dl</code>ed"
            ;;
        ytdledFlac)
            print "<code>youtube-dl</code>ed and transcoded to FLAC"
            ;;
        flacBounce)
            print "Work-in-progress FLAC bounce"
            ;;
        aiffBounce)
            print "Work-in-progress AIFF bounce"
            ;;
        flac)
            print "FLAC"
            ;;
        alac)
            print "M4A: Apple Lossless Audio Codec"
            ;;
        cdRip)
            print "CD Rip"
            ;;
        zipRelease)
            print "ZIP release <small>(historic packing)</small>"
            ;;
        zipSession)
            print "ZIP file containing work from the session"
            ;;
        artSource)
            print "Artwork production files"
            ;;
        releaseSource)
            print "Release production files"
            ;;
        soundSource)
            print "Music production files"
            ;;
        releaseTracks)
            print "Original release tracks <small>(packing not original)</small>"
            ;;
        nonPngArtwork)
            print "Nonstandard artwork"
            ;;
        samplesWork)
            print "Samples"
            ;;
        youtubeSourceFile)
            print "YouTube source file"
            ;;
        fileIsSemanticallySignificant)
            print "File is semantically significant"
            ;;
        fmCatNum)
            print "Catalog number"
            ;;
        oldFmCatNum)
            print "Original catalog number"
            ;;
        hypFmCatNum)
            print "Two-part old catalog number"
            ;;
        isAliasOf)
            print "Is alias of"
            ;;
        hasAlias)
            print "Has alias"
            ;;
        legalName)
            print "Legal name"
            ;;
        ia)
            print "Internet Archive"
            ;;
        youtube)
            print "YouTube"
            ;;
        *)
            print "${1^}"
            ;;
    esac
}

buildTrackPlayer() {
    local workIdentifier="$1"
    local releaseIdentifier="$2"
    local filename
    filename="$(discReadConf filename work "$workIdentifier")"
    local extA
    extA="$(discReadConf origExt work "$workIdentifier")"
    local extB
    extB="$(discReadConf origExtB work "$workIdentifier")"
    local extC
    extC="$(discReadConf origExtC work "$workIdentifier")"
    if [[ "$extA" == "ogg" || "$extB" == "ogg" || "$extC" == "ogg" ]]; then
        local hasOgg="true"
    elif [[ "$extA" == "flac" || "$extB" == "flac" || "$extC" == "flac" ]]; then
        local hasFlac="true"
    elif [[ "$extA" == "mp3" || "$extB" == "mp3" || "$extC" == "mp3" ]]; then
        local hasMp3="true"
    fi
    if ! [[ "$hasOgg" == "true" ]]; then
        simpleIaLink release "$releaseIdentifier" "$filename".ogg "OGA"
    else
        simpleIaLink release "$releaseIdentifier" "$filename".ogg "Orig. (OGA)"
    fi
    print " "
    if ! [[ "$hasFlac" == "true" ]]; then
        simpleIaLink release "$releaseIdentifier" "$filename".flac "FLAC"
    else
        simpleIaLink release "$releaseIdentifier" "$filename".flac "Orig. (FLAC)"
    fi
    print " "
    if ! [[ "$hasMp3" == "true" ]]; then
        simpleIaLink release "$releaseIdentifier" "$filename".mp3 "MP3"
    else
        simpleIaLink release "$releaseIdentifier" "$filename".mp3 "Orig. (MP3)"
    fi
    if [[ "$extA" != "ogg" && "$extA" != "mp3" && "$extA" != "flac" ]]; then
        print " "
        simpleIaLink release "$releaseIdentifier" "$filename.$extA" "Orig. ($(keyToLabel "$extA"))"
    fi
    if [[ "$extB" != "ogg" && "$extB" != "mp3" && "$extB" != "flac" ]]; then
        print " "
        simpleIaLink release "$releaseIdentifier" "$filename.$extB" "Orig. ($(keyToLabel "$extB"))"
    fi
    if [[ "$extC" != "ogg" && "$extC" != "mp3" && "$extC" != "flac" ]]; then
        print " "
        simpleIaLink release "$releaseIdentifier" "$filename.$extC" "Orig. ($(keyToLabel "$extC"))"
    fi
    print '<br />'
    print '<audio controls preload="none">'
    local formats=(ogg flac mp3)
    for format in "${formats[@]}"; do
        print '<source src="'
        simpleIaUrl release "$releaseIdentifier" "$filename.$format"
        print '" type="audio/'
        if [[ "$format" == "mp3" ]]; then
            print "mpeg"
        else
            print "$format"
        fi
        print '">'
    done
    print "Could not start audio player.</audio>"
}

traitToHtm() {
    local kind="$1"
    local identifier="$2"
    local key="$3"
    local value="$4"
    local outputMode="$5"
    case "$key" in
        file)
            print "<li>$(simpleIaLink "$kind" "$identifier" "${value#*,}" "$(keyToLabel "${value%%,*}")")</li>"
            ;;
        nonPngArtwork)
            simpleMetadata "$(keyToLabel "$key")" "$(simpleIaLink "$value" "$identifier" "$value")"
            ;;
        fileIsSemanticallySignificant)
            if [[ "$value" == "yes" ]]; then
                simpleMetadata "$(keyToLabel "$key")" "yes"
            fi
            ;;
        artworkcount)
            local reverseThumbnailPattern=""
            local artcountValue="$value"
            if [[ "${value: -1}" == "t" ]]; then
                reverseThumbnailPattern="true"
                artcountValue="${value:: -1}"
            fi
            simpleMetadata "$(keyToLabel "$key")" "$(
                local end="$artcountValue"
                for (( i=1; i<=end; i++ )); do
                    if [[ "$outputMode" == "featured-content" ]]; then
                        simpleIaImage --featured-content-page "$kind" "$identifier" "$i" "$reverseThumbnailPattern"
                    else
                        simpleIaImage "$kind" "$identifier" "$i" "$reverseThumbnailPattern"
                    fi
                    [[ "$i" != "$end" ]] && print ' '
                done
            )"
            ;;
        track)
            local trackCounter
            trackCounter="$(getTrackCounter)"
            setTrackCounter $(( trackCounter + 1 ))
            local work="${value%%,*}"
            local subWork="${value#*,}"
            local workPrefix
            workPrefix="$(getRelativeDiscographyDir)works/$work/$subWork"
            #discogDebug "Called preadconf name ""$workPrefix.conf"", got $(preadconf name "$workPrefix.conf")"
            local nameColumn=""
            local extraColumns=""
            if [[ "$outputMode" != "featured-content" ]]; then
                nameColumn="<a href=\"$workPrefix.htm\">$(preadconf name "$workPrefix.conf")</a>"
                extraColumns="<td>$(preadconf instrumentation "$workPrefix.conf")</td>"
            else
                nameColumn="$(preadconf name "$workPrefix.conf")"
            fi
            print "    <tr><td>$(getTrackCounter)</td><td>$(buildTrackPlayer "$work/$subWork" "$identifier")</td><td>$nameColumn</td><td>$(preadconf duration "$workPrefix.conf")</td>$extraColumns</tr>"
            ;;
        medium)
            simpleMetadata "$(keyToLabel "$key")" "$(keyToLabel "$value")"
            ;;
        label)
            if [[ "$outputMode" == "featured-content" ]]; then
                simpleMetadata "$(keyToLabel "$key")" "$(discReadConf name label "$value")"
            else
                simpleReference "$key" label "$value"
            fi
            ;;
        artist)
            simpleReference "$key" artist "$value"
            ;;
        work)
            simpleReference "$key" work "${value/,/\/}"
            ;;
        samplesWork)
            simpleReference "$key" work "${value/,/\/}"
            ;;
        release)
            simpleReference "$key" release "$value"
            ;;
        shortDate)
            if [[ "$outputMode" == "featured-content" ]]; then
                simpleMetadata "$(keyToLabel "$key")" "$value"
            else
                true
            fi
            ;;
        name)
            true
            ;;
        featured)
            true
            ;;
        nextId)
            true
            ;;
        context)
            local contextKind="${value%%,*}"
            simpleMetadata "$(keyToLabel "$key")" "${contextKind^}: $(linkToItem --with-date "$contextKind" "${value#*,}" false)"
            ;;
        hasAlias)
            simpleReference "$key" artist "$value"
            ;;
        isAliasOf)
            simpleReference "$key" artist "$value"
            ;;
        "* Identifiers *")
            closeCurrentSection
            print $'\n\n'"<h2>Identifiers</h2>"$'\n'"<dl>"
            setClosingTag "</dl>"
            ;;
        "* Relationships *")
            true
            ;;
        "* Specs *")
            true
            ;;
        "* Files *")
            closeCurrentSection
            print $'\n\n'"<h2>Files</h2>"$'\n'"<ul>"
            setClosingTag "</ul>"
            ;;
        "* Tracks *")
            closeCurrentSection
            setTrackCounter "0"
            local extraColumnsHeader="<th>Instrumentation</th>"
            if [[ "$outputMode" == "featured-content" ]]; then
                extraColumnsHeader=""
            else
                print $'\n\n'"<h2>Track listing</h2>"
            fi
            print $'\n'"<table>"$'\n    '"<thead><tr><th>#</th><th>🔊</th><th>Track name</th><th>Duration</th>$extraColumnsHeader</tr></thead>"$'\n    '"<tbody>"
            local newClosingTagSuffix=""
            if [[ "$outputMode" != "featured-content" ]]; then
                newClosingTagSuffix=$'\n''<script src="/discography-dist/player.js"></script>'
            fi
            setClosingTag "    </tbody>"$'\n'"</table>"$'\n'"$newClosingTagSuffix"
            ;;
        mbid)
            simpleMetadata "$(keyToLabel "$key")" "<a href=\"https://musicbrainz.org/${kind%s}/$value\">$value</a>"
            ;;
        ia)
            iaItemsFilePath="$(getRelativeDiscographyDir)/futuramerlin-web-toolkit-discography.iaidentifiers"
            echo "$value" >> "$iaItemsFilePath"
            removeDuplicateLines "$iaItemsFilePath" | sponge "$iaItemsFilePath"
            simpleMetadata "$(keyToLabel "$key")" "<a href=\"https://archive.org/details/$value\">$value</a>"
            ;;
        youtube)
            simpleMetadata "$(keyToLabel "$key")" "<a href=\"https://youtube.com/watch?v=$value\">$value</a>"
            ;;
        *)
            simpleMetadata "$(keyToLabel "$key")" "$value"
            ;;
    esac
}

setTrackCounter() {
    print "$1" > "$trackCounterFile"
}

getTrackCounter() {
    cat "$trackCounterFile"
}

setClosingTag() {
    print "$1" > "$closingTagFile"
}

closeCurrentSection() {
    closingTag="$(<"$closingTagFile")"
    if [[ -n "$closingTag" ]]; then
        print $'\n'"$closingTag"
        setClosingTag ''
    fi
}

buildInfoTable() {
    local kind="$1"
    local identifier="$2"
    local infoTableBuildRequestType="$3"
    local foundInfo=""
    while IFS= read -r line; do
        local pattern='^#'
        if ! [[ "$line" =~ $pattern ]]; then
            local key="${line%%,*}"
            if [[ -n "$key" ]]; then
                if [[ "$infoTableBuildRequestType" == "featured-content" ]]; then
                    if ( [[ "$key" != "artworkcount" ]] && [[ "$key" != "shortDate" ]] && [[ "$key" != "date" ]] && [[ "$key" != "duration" ]] && [[ "$key" != "label" ]] && [[ "$key" != '* Tracks *' ]] && [[ "$key" != "track" ]] ); then
                        continue
                    fi
                fi
                if [[ "$foundInfo" != "true" ]]; then
                    if [[ "$infoTableBuildRequestType" == "featured-content" ]]; then
                        setClosingTag "</dl>"$'\n<!-- futuramerlin-web-toolkit insert to preserve newline during processing -->'
                    else
                        setClosingTag "</dl>"
                    fi
                    foundInfo="true"
                    print '<dl>'
                fi
                if [[ "$infoTableBuildRequestType" == "featured-content" ]]; then
                    if [[ "$key" == 'date' ]]; then
                        local shortDateValue
                        shortDateValue=$(discReadConf shortDate "$kind" "$identifier")
                        if [[ -n "$shortDateValue" ]]; then
                            continue
                        fi
                    fi
                fi
                local value="${line#*,}"
                local traitHtm
                traitHtm="$(traitToHtm "$kind" "$identifier" "$key" "$value" "$infoTableBuildRequestType")"
                if [[ -n "$traitHtm" ]]; then
                    #discogDebug "Got trait from $kind $identifier $key $value: \'$traitHtm\'"
                    local pattern='^'$'\n''<\/'
                    if [[ "$traitHtm" =~ $pattern ]]; then
                        print "$traitHtm"
                    else
                        print $'\n    '"$traitHtm"
                    fi
                fi
            fi
        fi
    done < "$(getItemPath "$kind" "$identifier").conf"
    if [[ "$foundInfo" == "true" ]]; then
        closeCurrentSection
    fi
}

buildLeafContents() {
    local leafContentsBuildRequestType="normal"
    if [[ "$1" == "--featured-navigation-link" ]]; then
        leafContentsBuildRequestType="featured-navigation-link"
        shift
    elif [[ "$1" == "--featured-content" ]]; then
        leafContentsBuildRequestType="featured-content"
        shift
    fi
    local kind="$1"
    local identifier="$2"

    if [[ "$leafContentsBuildRequestType" == "featured-navigation-link" || "$leafContentsBuildRequestType" == "featured-content" ]]; then
        if [[ "$(discReadConf featured "$kind" "$identifier")" != "true" ]]; then
            return
        fi
        if [[ "$leafContentsBuildRequestType" == "featured-navigation-link" ]]; then
            local thumbnailPrefix=""
            local thumbnailSuffix="t"
            local artcountValue
            artcountValue="$(discReadConf artworkcount "$kind" "$identifier")"
            if [[ "${artcountValue: -1}" == "t" ]]; then
                thumbnailPrefix="t"
                thumbnailSuffix=""
            fi
            local tempName
            tempName="$(discReadConf name "$kind" "$identifier")"
            print "        <img src=\"releases/$identifier/$thumbnailPrefix""1""$thumbnailSuffix.png\" alt=\"$(htmlToText.pl <<< "$tempName" | normalizeWhitespace): album artwork\" width=\"150\" onclick=\"toggle('$identifier')\" class=\"musicthumb\" />"$'\n'
            return
        fi
    fi
    if [[ "$leafContentsBuildRequestType" == "featured-content" ]]; then
        print "        <div class=\"musicbig\" id=\"$identifier\">"$'\n'"            <h2>$(discReadConf name "$kind" "$identifier")</h2>"$'\n'
    fi

    local disambig
    disambig="$(discReadConf disambig "$kind" "$identifier")"
    if [[ -n "$disambig" ]]; then
        disambig="<p><strong>($disambig)</strong></p>"
    else
        disambig=""
    fi
    if [[ "$leafContentsBuildRequestType" == "featured-content" ]]; then
        print "$disambig"
    else
        print "$disambig"$'\n\n'
    fi

    local pattern='.*\/.*'
    if [[ "$kind" =~ $pattern ]]; then
        # This kind is for a sub-item
        local key="${kind%%\/*}"
        local value="${kind#*\/}"
        print '<p>This is an instance of the work '
        linkToItem --with-date "$key" "$value" false
        print '.</p>'$'\n\n'
    fi

    if [[ "$leafContentsBuildRequestType" == "featured-content" ]]; then
        buildInfoTable "$kind" "$identifier" "$leafContentsBuildRequestType" | sed -En 's/^(.+)$/            \1/p'
    else
        buildInfoTable "$kind" "$identifier" "$leafContentsBuildRequestType"
    fi

    if [[ "$leafContentsBuildRequestType" == "featured-content" ]]; then
        print $'\n'"        </div>"
        return
    fi

    if [[ "$kind" == "artist" ]] || [[ "$kind" == "label" ]]; then
        releasesList="$(listRecursive release --filter "$kind" "$identifier" | tac -b | tail -c +1)"
        if [[ -n "$releasesList" ]]; then
            print $'\n\n'
            print '<h2>Releases</h2>'$'\n'"<ul>$releasesList"$'\n'"</ul>"
        fi
        true # needed because the if statement executes with the exit status of the last command executed
    fi

    if [[ -d "$(getItemPath "$kind" "$identifier")" ]] && [[ ! "$kind" == "release" ]]; then
        # This item has sub-items (e.g. instances of works), so build them now
        (
            cd "$identifier" || die
            print $'\n\n''<h2>Instances</h2>'$'\n'"<ul>"
            { listRecursive "$kind/$identifier"; print $'\n'; } | while IFS= read -r line; do
                print "${line//..\/..\//..\/}"$'\n'
            done
            print "</ul>"
        )
    fi
}

listRecursive() {
    discogDebug "listRecursive called with args $1 $2 $3 $4"
    local kind="$1"
    local filtered=""
    local filterKey
    local filterValue
    if [[ "$2" == "--filter" ]]; then
        filtered="true"
        filterKey="$3"
        filterValue="$4"
    fi
    local entryPoint
    entryPoint="$(getEntryPoint "$kind")"
    if [[ -z "$entryPoint" ]]; then
        # This is a list to display alphabetically
        # Pipe to tac to reverse order, because it will get reversed again later (to make the dates display newest to oldest of recursively listed items).
        if [[ "$filtered" == "true" ]]; then
            listAlphabetical "$kind" --filter "$filterKey" "$filterValue" | tac -b | tail -c +1
        else
            listAlphabetical "$kind" | tac -b | tail -c +1
        fi
    else
        # We're making a chronological list, so start with the first item in the list (defined in the .entry-point file), and follow the chain along from there.
        if [[ "$filtered" == "true" ]]; then
            listItem --filter "$filterKey" "$filterValue" --recursive "$kind" "$entryPoint"
        else
            listItem --recursive "$kind" "$entryPoint"
        fi
    fi
}

listAlphabetical() {
    local kind="$1"
    local filtered=""
    local filterKey
    local filterValue
    if [[ "$2" == "--filter" ]]; then
        filtered="true"
        filterKey="$3"
        filterValue="$4"
    fi
    local itemList=""
    discogDebug "Building alphabetical list of $kind (filtered: $filtered $filterKey $filterValue)"
    for item in "$(getRelativeDiscographyDir)$(getKindFolderName "$kind")"/*.conf; do
        itemName="$(basename "$item")"
        itemName="${itemName%\.conf}"
        # This appends the current item to the list that this function will return.
        if [[ "$filtered" == "true" ]]; then
            itemList="$itemList$(listItem --filter "$filterKey" "$filterValue" "$kind" "$itemName")"
        else
            itemList="$itemList$(listItem "$kind" "$itemName")"
            # This causes the recursive page building, and doesn't have any effect on what this function returns.
            buildPage "$(getSubKind "$kind")$itemName" "$(getItemName "$kind" "$itemName")$(getKindDisplayNameInsert "$kind")" "$(getBreadcrumbs "$kind")" "$(buildLeafContents "$kind" "$itemName")"
        fi
    done
    print "$itemList"
}

buildList() {
    local kind="$1"
    discogDebug "Building list for $kind"
    print "<ul>"
    case "$kind" in
    kind)
        itemList=""
        itemList="$itemList"$'\n'"    <li><a href=\"./featured.htm\">Featured Releases</a></li>"
        indexItems=(artist label release work broadcast press session file)
        for item in "${indexItems[@]}"; do
            if [[ -e "$(getKindFolderName "$item")" ]]; then
                buildCategory "kind" "$item"
                itemList="$itemList$(listItem "kind" "$item")"
            fi
        done
        print "$itemList"
        ;;
    file)
        itemList="FIXME"
        ;;
    *)
        listRecursive "$kind" | tac -b | tail -c +1
        ;;
    esac
    print $'\n'"</ul>"
}

buildPage() {
    local destinationFile="$1"
    local pageTitle="$2"
    discogDebug "Building page $pageTitle in $(pwd): $destinationFile.htm"
    local pageBreadcrumbs="$3"
    local pageContent="$4"
    cp "$assets/template.htm" "$destinationFile.htm" || die
    ereplace "@TITLE@" "$pageTitle" "$destinationFile.htm"
    ereplace "@BREADCRUMBS@" "$pageBreadcrumbs" "$destinationFile.htm"
    ereplace "@BODY@" "$pageContent" "$destinationFile.htm"
    ereplace "@DISCOGRAPHYROOT@" "$(getRelativeDiscographyDir)" "$destinationFile.htm"
    ereplace $'\n\n\n' $'\n' "$destinationFile.htm" # If $pageContent was empty, there will be some line breaks left over, so remove them
}

buildCategory() {
    local kind="$1"
    local identifier="$2"
    discogDebug "Building category for the $kind $identifier"
    case "$kind" in
        index)
            buildPage "$discographyPageName" "Discography" "$indexBreadcrumbs" "$(buildList kind)"
            ;;
        kind)
            (
                itemKindFolderName="$(getKindFolderName "$identifier")"
                cd "$itemKindFolderName" || die
                identifierCategoryName="$itemKindFolderName"
                buildPage "index" "${identifierCategoryName^}" "$(getBreadcrumbs "$kind")" "$(buildList "$identifier")"
            )
            ;;
        *)
            error-notify "buildCategory requested for unknown type $kind."
            ;;
    esac
}

buildCategory "index"

# Finish featured releases page
print '    <div id="musicthumbnails">'$'\n''        <a href="javascript:toggle('\''musicintro'\'')" class="musicthumb">Introduction</a>'$'\n' >> "featured.htm"
tac "featured.htm.navigation" >> "featured.htm"
print '    </div>'$'\n\n''    <div id="musiccontents">'$'\n''        <div class="musicbig" id="musicintro">'$'\n''            <h2>Music</h2>'$'\n''            <p class="mdate">Choose a release from the column to the left, or <a href="releases">see all the releases instead of only featured releases</a>.<br /><br /><!-- TODO: put demo video here? --></p>'$'\n''        </div>'$'\n' >> "featured.htm"
tac "featured.htm.content" > "featured.htm.content.tmp"
ereplace '\n' $'\n' "featured.htm.content.tmp"
ereplace '            <!-- futuramerlin-web-toolkit insert to preserve newline during processing -->' '' "featured.htm.content.tmp"
cat "featured.htm.content.tmp" >> "featured.htm"
rm "featured.htm.content" "featured.htm.content.tmp" "featured.htm.navigation"
cat "$assets/featured-template-tail.htm" >> "featured.htm"

rm "${trackCounterFile:?}"
rm "${closingTagFile:?}"
