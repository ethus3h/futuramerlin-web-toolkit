#!/usr/bin/env bash
# shellcheck disable=SC1091
source ember_bash_setup &> /dev/null
trap 'die "A fatal error was reported on ${BASH_SOURCE[0]} line ${LINENO} in $(pwd)."' ERR

#set -x

sourceDir="$(readlink -f "$1")"

destDir="$(readlink -f "$2")"

[[ -e "$destDir" ]] && rm -r "$destDir"

rsync -a --checksum "$sourceDir/" "$destDir"

cd "$destDir" || die

if [[ ! -f "futuramerlin-web-toolkit-discography.conf" ]]; then
    die "Couldn't find discography configuration file!"
fi

# Where the discography assets are located
assets="/usr/local/share/futuramerlin-web-toolkit/assets/discography.assets"

# Variables
indexBreadcrumbs="$(<futuramerlin-web-toolkit-discography.breadcrumbs)"
indexBreadcrumbs="    ${indexBreadcrumbs//$'\n'/$'\n'    }"
indexBreadcrumbs="${indexBreadcrumbs%    }"
discographyPageName="$(preadconf filename futuramerlin-web-toolkit-discography.conf)"
trackCounterFile="$(readlink -f futuramerlin-web-toolkit-discography.conf).tc.temp"
echo "0" > "$trackCounterFile"
closingTagFile="$(readlink -f futuramerlin-web-toolkit-discography.conf).temp"
touch "$closingTagFile"

discogDebug() {
    echo "$@" 1>&2
    true
}

getRelativeDiscographyDir() {
    # discogDebug "$(pwd)"
    if [[ -f "futuramerlin-web-toolkit-discography.conf" ]]; then
        print "./"
    elif [[ -f "../futuramerlin-web-toolkit-discography.conf" ]]; then
        print "../"
    elif [[ -f "../../futuramerlin-web-toolkit-discography.conf" ]]; then
        print "../../"
    elif [[ -f "../../../futuramerlin-web-toolkit-discography.conf" ]]; then
        print "../../../"
    fi
}

mergeConfFile() {
    local inheritInto="$1"
    local inheritFrom
    inheritFrom="works/$(basename "$(dirname "$inheritInto")").conf"
    discogDebug "Merging from $inheritFrom into $inheritInto"
    while IFS= read -r line; do
        local pattern='^#'
        if ! [[ "$line" =~ $pattern ]]; then
            local key="${line%%,*}"
            if ! grep -P "^$key," "$inheritInto" > /dev/null; then
                printf "%s\\n" "$line" >> "$inheritInto"
            fi
        fi
    done < "$inheritFrom"
}

for file in works/*/*.conf; do
    mergeConfFile "$file"
done

getKindFolderName() {
    local kind="$1"
    local pattern='.*\/.*'
    if [[ "$kind" =~ $pattern ]]; then
        # This kind is for a sub-item
        local key="${kind%%\/*}"
        local value="${kind#*\/}"
        print "$(getKindFolderName "$key")/$value"
    elif [[ "$kind" == "press" ]]; then
        print "press"
    else
        print "${kind}s"
    fi
}

getKindLabel() {
    local kind="$1"
    local kindFolderName
    kindFolderName="$(getKindFolderName "$kind")"
    print "${kindFolderName^}"
}

getItemPath() {
    # Returns the prefix pathname (e.g. releases/sylfan) of the referenced item, relative to the current directory.
    local kind="$1"
    local identifier="$2"
    case "$kind" in
        kind)
            print "$(getRelativeDiscographyDir)$(getKindFolderName "$identifier")"
            ;;
        *)
            print "$(getRelativeDiscographyDir)$(getKindFolderName "$kind")/$identifier"
            ;;
    esac
}

discReadConf() {
    local key="$1"
    local kind="$2"
    local identifier="$3"
    #discogDebug "Reading configuration value $key from the $kind $identifier"
    preadconf "$key" "$(getItemPath "$kind" "$identifier").conf"
}

getItemName() {
    local kind="$1"
    local identifier="$2"
    if [[ "$kind" == "kind" ]]; then
        getKindLabel "$identifier"
    elif [[ "$kind" == "session" ]]; then
        print "$identifier: $(discReadConf location "$kind" "$identifier")"
    else
        discReadConf name "$kind" "$identifier"
    fi
}

linkToItem() {
    local includeArtistName=""
    if [[ "$1" == "--with-artist-name" ]]; then
        includeArtistName="true"
        shift
    fi
    local includeDate=""
    if [[ "$1" == "--with-date" ]]; then
        includeDate="true"
        shift
    fi
    local kind="$1"
    local identifier="$2"
    local usePicture="$3"
    local extraInfo="$4" # a formatting string like (@shortDate@)
    local picture=""
    local name
    local shortDate=""
    local extension
    name="$(getItemName "$kind" "$identifier")"
    if [[ "$kind" == "kind" ]]; then
        extension=""
    else
        if [[ "$includeDate" == "true" ]]; then
            shortDate="$(discReadConf shortDate "$kind" "$identifier")"
            if [[ -z "$shortDate" ]]; then
                shortDate="$(discReadConf date "$kind" "$identifier")"
            fi
            if [[ -n "$shortDate" ]]; then
                shortDate=" ($shortDate)"
            else
                shortDate=""
            fi
        fi
        extension=".htm"
    fi
    local linkFirstPart
    linkFirstPart="<a href=\"$(getItemPath "$kind" "$identifier")$extension\">"
    local artistNameInsert
    if [[ "$includeArtistName" == "true" ]]; then
        local artistId
        artistId="$(discReadConf artist "$kind" "$identifier")"
        artistNameInsert="</a> $(discReadConf fmCatNum "$kind" "$identifier") â€” $(discReadConf name artist "$artistId"): $linkFirstPart"
    else
        artistNameInsert=""
    fi
    if [[ "$usePicture" != "false" ]]; then
        local pictureType
        if [[ "$kind" == "release" ]]; then
            pictureType="album artwork"
        fi
        local picturePathName
        # .m.png = 50px; .t.png = 150px
        picturePathName="$(getItemPath "$kind" "$identifier").m.png"
        if [[ -e "$picturePathName" ]]; then
            picture="<img src=\"$picturePathName\" alt=\"$name: $pictureType thumbnail image\" />"
            if [[ "$artistNameInsert" == "" ]]; then
                artistNameInsert=" "
            fi
        fi
    fi
    # TODO: Implement extraInfo
    print "$linkFirstPart$picture$artistNameInsert$name</a>$shortDate"
}

simpleMetadata() {
    print "<dt>$1</dt><dd>$2</dd>"
}

simpleReference() {
    local key="$1"
    local kind="$2"
    local identifier="$3"
    simpleMetadata "$(keyToLabel "$key")" "$(linkToItem "$kind" "$identifier")"
}

getEntryPoint() {
    local kind="$1"
    local entryPointFile
    entryPointFile="$(getRelativeDiscographyDir)/$kind/futuramerlin-web-toolkit-discography.entry-point"
    if [[ -e "$entryPointFile" ]]; then
        print "$(<"$entryPointFile")"
    fi
}

getLeafBreadcrumbs() {
    local kind="$1"
    local superKind="$2"
    local pattern='.*\/.*'
    if [[ "$kind" != "kind" ]] && [[ "$kind" != "index" ]]; then
        if [[ "$kind" =~ $pattern ]]; then
            # This kind is for a sub-item
            local key="${kind%%\/*}"
            local value="${kind#*\/}"
            getLeafBreadcrumbs "$key"
            getLeafBreadcrumbs "$value" "$key"
        else
            print $'\n'"    <span><a href=\""
            getRelativeDiscographyDir
            if [[ -n "$superKind" ]]; then
                print "$(getKindFolderName "$superKind")/$kind.htm"
            else
                print "$(getKindFolderName "$kind")"
            fi
            print "\">"
            if [[ -n "$superKind" ]]; then
                getItemName "$superKind" "$kind"
            else
                getKindLabel "$kind"
            fi
            print "</a></span>"
        fi
    fi
}

getBreadcrumbs() {
    local kind="$1"
    print "$indexBreadcrumbs"$'\n'"    <span><a href=\"../$discographyPageName.htm\">Discography</a></span>"
    getLeafBreadcrumbs "$kind"
}

getSubKind() {
    local kind="$1"
    local pattern='.*\/.*'
    if [[ "$kind" =~ $pattern ]]; then
        print "../"
        getKindFolderName "$kind"
        print "/"
    fi
}

listItem() {
    local filtered=""
    local filterKey
    local filterValue
    if [[ "$1" == "--filter" ]]; then
        filtered="true"
        shift
        filterKey="$1"
        shift
        filterValue="$1"
        shift
    fi
    local recursive="false"
    if [[ "$1" == "--recursive" ]]; then
        # It's recursive, so the outermost call to listItem will actually return the results for *all* items in the chain.
        recursive="true"
        shift
    fi
    # Remaining arguments are the same as for linkToItem
    local kind="$1"
    local identifier="$2"
    discogDebug "Building list entry for an item: $kind $identifier. Recursive: $recursive. Filtered: $filtered $filterKey $filterValue"
    local usePicture="$3"
    local extraInfo="$4" # a formatting string like (@shortDate@)
    local matchedFilter=""
    if [[ "$filtered" == "true" ]]; then
        if [[ "$(discReadConf "$filterKey" "$kind" "$identifier")" == "$filterValue" ]]; then
            matchedFilter="true"
        fi
    fi
    if [[ "$filtered" != "true" ]] || [[ "$matchedFilter" == "true" ]]; then
        if [[ "$filterKey" == "label" ]]; then
            # Also print the artist name
            print $'\n'"    <li>$(linkToItem --with-artist-name --with-date "$@")</li>"
        else
            if [[ "$kind" == "broadcast" ]] || [[ "$kind" == "file" ]] || [[ "$kind" == "press" ]] || [[ "$kind" == "release" ]] || [[ "$kind" == "work" ]]; then
                print $'\n'"    <li>$(linkToItem --with-date "$@")</li>"
            else
                print $'\n'"    <li>$(linkToItem "$@")</li>"
            fi
        fi
    fi
    if [[ "$recursive" == "true" ]]; then
        if [[ "$filtered" != "true" ]]; then
            # We need to call buildPage in here, because unlike with alphabetical lists, it won't be called by listRecursive
            buildPage "$(getSubKind "$kind")$identifier" "$(getItemName "$kind" "$identifier")" "$(getBreadcrumbs "$kind")" "$(buildLeafContents "$kind" "$identifier")"
        fi
        # This is where we make the recursive call to listItem, if needed.
        local nextIdentifier
        nextIdentifier="$(discReadConf nextId "$kind" "$identifier")"
        [[ -n "$nextIdentifier" ]] && listItem --recursive "$kind" "$nextIdentifier" "$usePicture" "$extraInfo"
        true # needed because the if statement executes with the exit status of the last command executed
    fi
}

simpleIaLink() {
    local kind="$1"
    local identifier="$2"
    local iafilename="$3"
    local label="$4"
    local iaident
    iaident="$(discReadConf ia "$kind" "$identifier")"
    print "<a href=\"https://archive.org/download/$iaident/$iafilename\">$label</a>"
}

simpleIaUrl() {
    local kind="$1"
    local identifier="$2"
    local iafilename="$3"
    local iaident
    iaident="$(discReadConf ia "$kind" "$identifier")"
    print "https://archive.org/download/$iaident/$iafilename"
}

simpleIaImage() {
    local kind="$1"
    local identifier="$2"
    local iafilename="$3"
    local iaident
    iaident="$(discReadConf ia "$kind" "$identifier")"
    local relname
    relname="$(discReadConf name "$kind" "$identifier")"
    print "<a href=\"https://archive.org/download/$iaident/$iafilename.png\"><img src=\"https://archive.org/download/$iaident/t$iafilename.png\" alt=\"$relname: album artwork\" /></a>"
}

keyToLabel() {
    case $1 in
        dateBegun)
            print "Date begun"
            ;;
        mbid)
            print "MusicBrainz"
            ;;
        alac)
            print "M4A: Apple Lossless Audio Codec"
            ;;
        cdRip)
            print "CD Rip"
            ;;
        zipRelease)
            print "ZIP release <small>(historic packing)</small>"
            ;;
        artSource)
            print "Artwork production files"
            ;;
        soundSource)
            print "Music production files"
            ;;
        releaseTracks)
            print "Original release tracks <small>(packing not original)</small>"
            ;;
        nonPngArtwork)
            print "Nonstandard artwork"
            ;;
        fileIsSemanticallySignificant)
            print "File is semantically significant"
            ;;
        fmCatNum)
            print "Catalog number"
            ;;
        oldFmCatNum)
            print "Original catalog number"
            ;;
        hypFmCatNum)
            print "Two-part old catalog number"
            ;;
        isAliasOf)
            print "Is alias of"
            ;;
        hasAlias)
            print "Has alias"
            ;;
        legalName)
            print "Legal name"
            ;;
        ia)
            print "Internet Archive"
            ;;
        *)
            print "${1^}"
            ;;
    esac
}

buildTrackPlayer() {
    local workIdentifier="$1"
    local releaseIdentifier="$2"
    local filename
    filename="$(discReadConf filename work "$workIdentifier")"
    local extA
    extA="$(discReadConf origExt work "$workIdentifier")"
    if [[ -n "$extA" ]]; then
        simpleIaLink release "$releaseIdentifier" "$filename.$extA" "Orig. ($extA)"
        print " "
    fi
    local extB
    extB="$(discReadConf origExtB work "$workIdentifier")"
    if [[ -n "$extB" ]]; then
        simpleIaLink release "$releaseIdentifier" "$filename.$extB" "Orig. ($extB)"
        print " "
    fi
    local extC
    extC="$(discReadConf origExtC work "$workIdentifier")"
    if [[ -n "$extC" ]]; then
        simpleIaLink release "$releaseIdentifier" "$filename.$extC" "Orig. ($extC)"
        print " "
    fi
    if [[ "$extA" == "flac" || "$extB" == "flac" || "$extC" == "flac" ]]; then
        local hasFlac="true"
    elif [[ "$extA" == "mp3" || "$extB" == "mp3" || "$extC" == "mp3" ]]; then
        local hasMp3="true"
    elif [[ "$extA" == "ogg" || "$extB" == "ogg" || "$extC" == "ogg" ]]; then
        local hasOgg="true"
    fi
    if ! [[ "$hasMp3" == "true" ]]; then
        simpleIaLink release "$releaseIdentifier" "$filename".mp3 "MP3"
        print " "
    fi
    if ! [[ "$hasFlac" == "true" ]]; then
        simpleIaLink release "$releaseIdentifier" "$filename".flac "FLAC"
        print " "
    fi
    if ! [[ "$hasOgg" == "true" ]]; then
        simpleIaLink release "$releaseIdentifier" "$filename".ogg "OGA"
    fi
    print "<br />"
    print "<audio controls preload=\"none\">"
    local formats=(flac ogg mp3)
    for format in "${formats[@]}"; do
        print "<source src=\""
        simpleIaUrl release "$releaseIdentifier" "$filename.$format"
        print "\" type=\"audio/"
        if [[ "$format" == "mp3" ]]; then
            print "mpeg"
        else
            print "$format"
        fi
        print "\">"
    done
    print "Could not start audio player.</audio>"
}

traitToHtm() {
    local kind="$1"
    local identifier="$2"
    local key="$3"
    local value="$4"
    case "$key" in
        file)
            print "<li>$(simpleIaLink "$kind" "$identifier" "${value#*,}" "$(keyToLabel "${value%%,*}")")</li>"
            ;;
        nonPngArtwork)
            simpleMetadata "$(keyToLabel "$key")" "$(simpleIaLink "$value" "$identifier" "$value")"
            ;;
        fileIsSemanticallySignificant)
            if [[ "$value" == "yes" ]]; then
                simpleMetadata "$(keyToLabel "$key")" "yes"
            fi
            ;;
        artworkcount)
            local end="$value"
            for (( i=1; i<=end; i++ )); do
                simpleIaImage "$kind" "$identifier" "$i"
                print ' '
            done
            ;;
        track)
            local trackCounter
            trackCounter="$(getTrackCounter)"
            setTrackCounter $(( trackCounter + 1 ))
            local work="${value%%,*}"
            local subWork="${value#*,}"
            local workPrefix
            workPrefix="$(getRelativeDiscographyDir)/works/$work/$subWork"
            print "    <tr><td>$(getTrackCounter)</td><td>$(buildTrackPlayer "$work/$subWork" "$identifier")</td><td><a href=\"$workPrefix.htm\">$(preadconf name "$workPrefix.conf")</a></td><td>$(preadconf duration "$workPrefix.conf")</td><td>$(preadconf instrumentation "$workPrefix.conf")</td></tr>"
            ;;
        medium)
            simpleMetadata "$(keyToLabel "$key")" "$(keyToLabel "$value")"
            ;;
        label)
            simpleReference "$key" label "$value"
            ;;
        artist)
            simpleReference "$key" artist "$value"
            ;;
        work)
            simpleReference "$key" work "${value/,/\/}"
            ;;
        shortDate)
            true
            ;;
        name)
            true
            ;;
        nextId)
            true
            ;;
        context)
            simpleReference "$key" "${value%%,*}" "${value#*,}"
            ;;
        hasAlias)
            simpleReference "$key" artist "$value"
            ;;
        isAliasOf)
            simpleReference "$key" artist "$value"
            ;;
        "* Identifiers *")
            closeCurrentSection
            print $'\n\n'"<h2>Identifiers</h2>"$'\n'"<dl>"
            setClosingTag "</dl>"
            ;;
        "* Relationships *")
            true
            ;;
        "* Specs *")
            true
            ;;
        "* Files *")
            closeCurrentSection
            print $'\n\n'"<h2>Files</h2>"$'\n'"<ul>"
            setClosingTag "</ul>"
            ;;
        "* Tracks *")
            closeCurrentSection
            print $'\n\n'"<h2>Track listing</h2>"$'\n'"<table>"$'\n    '"<thead><tr><th>#</th><th>ðŸ”Š</th><th>Track name</th><th>Duration</th><th>Instrumentation</th></tr></thead>"$'\n    '"<tbody>"
            setClosingTag "    </tbody>"$'\n'"</table>"
            ;;
        mbid)
            simpleMetadata "$(keyToLabel "$key")" "<a href=\"https://musicbrainz.org/${kind%s}/$value\">$value</a>"
            ;;
        ia)
            simpleMetadata "$(keyToLabel "$key")" "<a href=\"https://archive.org/details/$value\">$value</a>"
            ;;
        *)
            simpleMetadata "$(keyToLabel "$key")" "$value"
            ;;
    esac
}

setTrackCounter() {
    print "$1" > "$trackCounterFile"
}

getTrackCounter() {
    cat "$trackCounterFile"
}

setClosingTag() {
    print "$1" > "$closingTagFile"
}

closeCurrentSection() {
    print $'\n'"$(<"$closingTagFile")"
}

buildInfoTable() {
    local kind="$1"
    local identifier="$2"
    local foundInfo=""
    while IFS= read -r line; do
        local pattern='^#'
        if ! [[ "$line" =~ $pattern ]]; then
            local key="${line%%,*}"
            if [[ -n "$key" ]]; then
                if [[ "$foundInfo" != "true" ]]; then
                    setClosingTag "</dl>"
                    foundInfo="true"
                    print '<dl>'
                fi
                local value="${line#*,}"
                local traitHtm
                traitHtm="$(traitToHtm "$kind" "$identifier" "$key" "$value")"
                if [[ -n "$traitHtm" ]]; then
                    #discogDebug "Got trait from $kind $identifier $key $value: \'$traitHtm\'"
                    local pattern='^'$'\n''<\/'
                    if [[ "$traitHtm" =~ $pattern ]]; then
                        print "$traitHtm"
                    else
                        print $'\n    '"$traitHtm"
                    fi
                fi
            fi
        fi
    done < "$(getItemPath "$kind" "$identifier").conf"
    if [[ "$foundInfo" == "true" ]]; then
        closeCurrentSection
    fi
}

buildLeafContents() {
    local kind="$1"
    local identifier="$2"
    buildInfoTable "$kind" "$identifier"
    if [[ "$kind" == "artist" ]] || [[ "$kind" == "label" ]]; then
        releasesList="$(listRecursive release --filter "$kind" "$identifier")"
        if [[ -n "$releasesList" ]]; then
            print $'\n\n'
            print '<h2>Releases</h2>'$'\n'"<ul>$releasesList"$'\n'"</ul>"
        fi
        true # needed because the if statement executes with the exit status of the last command executed
    fi

    if [[ -d "$(getItemPath "$kind" "$identifier")" ]]; then
        # This item has sub-items (e.g. instances of works), so build them now
        listRecursive "$kind/$identifier"
    fi
}

listRecursive() {
    discogDebug "listRecursive called with args $1 $2 $3 $4"
    local kind="$1"
    local filtered=""
    local filterKey
    local filterValue
    if [[ "$2" == "--filter" ]]; then
        filtered="true"
        filterKey="$3"
        filterValue="$4"
    fi
    local entryPoint
    entryPoint="$(getEntryPoint "$kind")"
    if [[ -z "$entryPoint" ]]; then
        if [[ "$filtered" == "true" ]]; then
            listAlphabetical "$kind" --filter "$filterKey" "$filterValue"
        else
            listAlphabetical "$kind"
        fi
    else
        # We're making a chronological list, so start with the first item in the list (defined in the .entry-point file), and follow the chain along from there.
        if [[ "$filtered" == "true" ]]; then
            listItem --filter "$filterKey" "$filterValue" --recursive "$kind" "$entryPoint"
        else
            listItem --recursive "$kind" "$entryPoint"
        fi
    fi
}

listAlphabetical() {
    local kind="$1"
    local filtered=""
    local filterKey
    local filterValue
    if [[ "$2" == "--filter" ]]; then
        filtered="true"
        filterKey="$3"
        filterValue="$4"
    fi
    local itemList=""
    discogDebug "Building alphabetical list of $kind (filtered: $filtered $filterKey $filterValue)"
    for item in ../"$(getKindFolderName "$kind")"/*.conf; do
        itemName="$(basename "$item")"
        itemName="${itemName%\.conf}"
        # This appends the current item to the list that this function will return.
        if [[ "$filtered" == "true" ]]; then
            itemList="$itemList$(listItem --filter "$filterKey" "$filterValue" "$kind" "$itemName")"
        else
            itemList="$itemList$(listItem "$kind" "$itemName")"
            # This causes the recursive page building, and doesn't have any effect on what this function returns.
            buildPage "$(getSubKind "$kind")$itemName" "$(getItemName "$kind" "$itemName")" "$(getBreadcrumbs "$kind")" "$(buildLeafContents "$kind" "$itemName")"
        fi
    done
    print "$itemList"
}

buildList() {
    local kind="$1"
    discogDebug "Building list for $kind"
    print "<ul>"
    case "$kind" in
    kind)
        itemList=""
        indexItems=(artist label release work broadcast press session file)
        for item in "${indexItems[@]}"; do
            if [[ -e "$(getKindFolderName "$item")" ]]; then
                buildCategory "kind" "$item"
                itemList="$itemList$(listItem "kind" "$item")"
            fi
        done
        print "$itemList"
        ;;
    file)
        itemList="FIXME"
        ;;
    *)
        listRecursive "$kind"
        ;;
    esac
    print $'\n'"</ul>"
}

buildPage() {
    local destinationFile="$1"
    local pageTitle="$2"
    discogDebug "Building page $pageTitle in $(pwd): $destinationFile.htm"
    local pageBreadcrumbs="$3"
    local pageContent="$4"
    cp "$assets/template.htm" "$destinationFile.htm" || die
    ereplace "@TITLE@" "$pageTitle" "$destinationFile.htm"
    ereplace "@BREADCRUMBS@" "$pageBreadcrumbs" "$destinationFile.htm"
    ereplace "@BODY@" "$pageContent" "$destinationFile.htm"
    ereplace $'\n\n\n' $'\n' "$destinationFile.htm" # If $pageContent was empty, there will be some line breaks left over, so remove them
}

buildCategory() {
    local kind="$1"
    local identifier="$2"
    discogDebug "Building category for the $kind $identifier"
    case "$kind" in
        index)
            buildPage "$discographyPageName" "Discography" "$indexBreadcrumbs" "$(buildList kind)"
            ;;
        kind)
            (
                cd "$(getKindFolderName "$identifier")" || die
                identifierCategoryName="$(getKindFolderName "$item")"
                buildPage "index" "${identifierCategoryName^}" "$(getBreadcrumbs "$kind")" "$(buildList "$identifier")"
            )
            ;;
        *)
            error-notify "buildCategory requested for unknown type $kind."
            ;;
    esac
}

buildCategory "index"

rm "${trackCounterFile:?}"
rm "${closingTagFile:?}"
